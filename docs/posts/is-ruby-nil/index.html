<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><link rel=stylesheet href=../../css/style.css><title>Is Ruby.nil? or Ruby.hype.dead? A current overview of Ruby - This is not a Monad Tutorial</title><meta name=generator content="Hugo 0.55.6"></head><body><div class=header>unbalancedparentheses
<span>: </span><a href=../../>Home</a><div><a href=https://github.com/unbalancedparentheses/ class=contact_link>github</a>
<span class=bar>|</span>
<a href=http://twitter.com/unbalancedparen/ class=contact_link>Twitter</a>
<span class=bar>|</span>
<a href=federico.carrone@lambdaclass.com class=contact_link>Contact</a></div></div><main><h1>Is Ruby.nil? or Ruby.hype.dead? A current overview of Ruby</h1><div class=details><span>posted on</span>
March 26, 2014<br></div><p class=content><h3 id=the-main-languages-i-ve-used-this-year>The main languages I’ve used this year</h3><p>My last post was a really short mention of the resources I have used to learn and develop my skills in JavaScript and Erlang. On this post I’m going to share with you some thoughts I have regarding Ruby’s present.</p><h2 id=ruby>Ruby</h2><p>Oh my dear Ruby, son of Lisp, Perl, Eiffel and Smalltalk, time has passed but I think you still are such an amazing creature. Sure, you need to resolve some issues. Everbody does. Some really intelligent doctors have stated that you are sick, that you might be dying, others are not quite sure about that:</p><ul><li><a href=http://jmoses.co/2013/12/21/is-ruby-dying.html>Is Ruby Dying?</a></li><li><a href=http://jmoses.co/2013/12/21/is-ruby-dying.html>Introducing Rubinius X</a></li><li>Good clarification about the previous post: <a href=http://www.infoworld.com/t/ruby-rails/rubinius-seeks-modernize-not-bury-the-ruby-language-229445>Rubinius seeks to modernize, not bury, the Ruby language</a></li><li><a href="https://news.ycombinator.com/item?id=6553767">Discussion on Hacker News about Introducing Rubinius X</a></li><li><a href=http://www.reddit.com/comments/1oi8wd>Discussion on Reddit about the Hacker News discussion</a>
**********</li></ul><h3 id=quantitative-analysis>Quantitative analysis</h3><p>Let’s start with some graphs. Everybody loves graphs!</p><p><img src=https://cdn-images-1.medium.com/max/800/1*QCE2zU-R9MKX6Sqj5lZNyQ.png alt></p><p><strong>Programming language popularity indexes</strong></p><p><a href=http://adambard.com/blog/top-github-languages-for-2013-so-far/>Ruby seems to be the second language</a> with more repositories (218812) created (without counting forks) between January 1(st and Aug 30th of 2013 on Github. JavaScript is the first with 264131 repositories created.</p><p>As reported by the <a href=https://en.wikipedia.org/wiki/TIOBE_index>TIOBE Index</a>, Ruby has descended one position on its ranking during this year. On January 2013, Ruby was the eleventh most used language and is now the <a href=http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html>twelfth</a>.</p><p><a href=http://www.tiobe.com/index.php/content/paperinfo/tpci/Ruby.html>TIOBE ratings for Ruby</a></p><p><img src=https://cdn-images-1.medium.com/max/800/1*gt6Mt5Fq20JpvL3DNwYBNA.png alt></p><p>According to the <a href=https://cdn-images-1.medium.com/max/800/1*gt6Mt5Fq20JpvL3DNwYBNA.png>Popularity of Programming Language index</a> (PYPL), Ruby is the ninth most popular programming language. PYPL is created by analyzing how often language tutorials are searched on Google.</p><p>According to <a href=http://redmonk.com/sogrady/2014/01/22/language-rankings-1-14/>RedMonk Programming Language Rankings</a>, at this moment, Ruby is the seventh most popular language based on correlations between GitHub’s and Stack Overflow’s rankings.</p><hr><h3 id=other-popularity-indicators>Other popularity indicators</h3><p>Let’s move onto other indicators.</p><p>Ruby conferences registered by <a href=http://lanyrd.com/>lanyrd</a> per year:</p><ul><li>2009: <a href=http://lanyrd.com/topics/ruby/2009/>16</a></li><li>2010: <a href=http://lanyrd.com/topics/ruby/2010/>50</a></li><li>2011: <a href=http://lanyrd.com/topics/ruby/2011/>139</a></li><li>2012: <a href=http://lanyrd.com/topics/ruby/2012/>188</a></li><li>2013: <a href=http://lanyrd.com/topics/ruby/2013/>207</a></li></ul><p>The absolute number of conferences kept on growing, however the growth speed diminished.</p><p><a href=http://lanyrd.com/topics/ruby/2009/>Module counts</a></p><p><img src=https://cdn-images-1.medium.com/max/800/1*syyHrXaZtCo9O1V6iTtTEQ.png alt></p><p>The number of modules seems to have kept growing at about the same speed for the last years.</p><p><a href=https://www.ohloh.net/p/ruby>Ruby’s lines of code</a></p><p><img src=https://cdn-images-1.medium.com/max/800/1*Dibiyr75hsGDLCatZTiRxQ.png alt></p><p>Ohloh reports that the Ruby language number of lines has grown at a steady speed.</p><p><a href="https://www.google.com/trends/explore#cat=0-5&amp;q=%2Fm%2F06ff5&amp;cmpt=q">Interest over time reported by Google Trends</a>:</p><p><img src=https://cdn-images-1.medium.com/max/800/1*bHHmLXNdXqaT9IbDoEcfpg.png alt></p><p>However the interest over time registered by Google seems to have plunked.</p><p><a href="http://www.indeed.com/jobtrends?q=ruby">Ruby and Javascript Indeed job trends (absolute)</a></p><p><img src=https://cdn-images-1.medium.com/max/800/1*kFX3kYHAfcR7_NuXO0PtbA.png alt></p><p><a href="http://www.indeed.com/jobtrends?q=ruby%2C+javascript&amp;l=&amp;relative=1">Ruby and Javascript Indeed job trends (relative)</a></p><p><img src=https://cdn-images-1.medium.com/max/800/1*IwJKDz6AwEQxl93gKlvM7g.png alt></p><p>Nevertheless, even if Ruby job postings are way down compared to JavaScript, they are still on the rise and its percentage growth continues to be quite important. In the startup world, there are at least <a href=https://angel.co/javascript/jobs>five startups</a> registered on AngelList that need a JavaScript developer for <a href=https://angel.co/ruby/jobs>each startup</a> that needs at least someone with Ruby knowledge.</p><p>These statistics show that even though Ruby is not as popular as it was a few years ago, it’s still a big player.</p><hr><h3 id=qualitative-data>Qualitative data</h3><p>So far, we have seen some numbers. Now it’s a good time to check other indicators that account for liveliness of Ruby.</p><p><img src=https://cdn-images-1.medium.com/max/800/1*P_BdP89ac9dcWAMDTBoaPw.png alt></p><p>Let me mention a few interesting tools created in Ruby apart from Rails and other web frameworks such as Sinatra or Padrino. I think this might give an idea about Ruby’s usage. <a href=http://brew.sh/>Homebrew</a>, coded in Ruby, is the simplest and more useful package manager for Mac OS X. Even if I prefer other alternatives, created in Nodejs, such as <a href=https://github.com/bevry/docpad>Docpad</a>, Jekyll, which is coded in Ruby, was one of the main reasons for the popularity of static page generators. <a href=http://www.discourse.org/>Discourse</a>, the best discussion platform. <a href=http://artoo.io/>Artoo</a> is a micro-framework for robotics. I don’t know a heck about it. Ruby also has got the two most used IT automation tools that exist: <a href=http://www.getchef.com/chef/>Chef</a> and <a href=http://puppetlabs.com/>Puppet</a>. These are two really big players that won’t disappear anytime soon and it doesn’t look as though they want to move away from Ruby.</p><p>Regarding books, Ruby always had great and fascinating books such as:</p><ul><li><a href=http://mislav.uniqpath.com/poignant-guide/>Why’s (Poignant) Guide to Ruby</a></li><li><a href=http://www.confidentruby.com/>Confident Ruby</a></li><li><a href=http://www.poodr.com/>Practical Object-Oriented Design in Ruby (POODR)</a></li><li><a href=http://eloquentruby.com/>Eloquent Ruby</a></li><li><a href=http://pragprog.com/book/ager/exceptional-ruby>Exceptional Ruby: Master the Art of Handling Failure in Ruby</a></li><li><a href=http://www.manning.com/black2/>The Well-Grounded Rubyist</a></li></ul><p>And now we got <a href=http://patshaughnessy.net/ruby-under-a-microscope>Ruby under a microscope</a>. One of the latest and greatest books about Ruby that keeps up with this tradition of precious books.</p><p>Last but not least, let’s see some Ruby talks:</p><ul><li><a href="https://www.youtube.com/watch?v=fyq8Z6E5E14">Ruby-Core dilemmas by Marc-André Lafortune</a></li><li><a href="https://www.youtube.com/watch?v=wPu2kVI09Yc">Towards Tooling; A Look at What is Missing From our Toolbox</a></li><li><a href="https://www.youtube.com/watch?v=mhXyNGX38mw">Ruby On Robots Using Artoo by Ron Evans</a></li><li><a href="https://www.youtube.com/watch?v=mhXyNGX38mw">Thinking about Machine Learning with Ruby by Bryan Liles</a></li><li><a href=http://youtu.be/cO26TjhQWvA>Machine Learning with Ruby</a></li><li><a href=http://michaelrbernste.in/2013/06/10/to-know-a-garbage-collector-goruco-2013.html>To Know A Garbage Collector</a></li></ul><p>As we can see, very different pieces of software are crafted with Ruby and Ruby developers seem to be attracted by very different things. From my point of view these are only examples that show how much life there is on the Ruby world. In my humble opinion Ruby is not going to die anytime soon. I think that, while Ruby’s hype is dead, the language and its great community have a great future.</p><hr><h3 id=ruby-s-hardest-problem>Ruby’s hardest problem</h3><p>This doesn’t mean there are no problems on Ruby. Ruby seems to be in the same order of magnitude in terms of speed than <a href=http://www.unlimitednovelty.com/2012/06/ruby-is-faster-than-python-php-and-perl.html>Python, PHP, and Perl</a> but in general Ruby it is not the fastest kid on the block. Even Matsumoto, its creator, admits it!</p><blockquote><p><em><a href="http://www.infoworld.com/d/application-development/infoworld-interview-ruby-creator-sets-sights-mobile-171503?page=0,1">Yukihiro Matsumoto details the past, present, and future of the popular programming language, calling mobile ‘the way to go’</a></em></p><p><em><strong>InfoWorld</strong>: Are there any limitations with developing Ruby applications?</em></p><p><em><strong>Matsumoto</strong>: Well, in some cases, performance could be the limitation. For example, Twitter was originally written in Ruby, but it has now has billions of users so, it’s larger, its core [is now] on top of the JVM. It was originally running on C Ruby, my Ruby. [With Twitter’s JVM-based program], the program is written in Scala and Clojure</em>.</p></blockquote><p>I think Matsumoto represents very well the self-critical spirit of the Ruby community. But it would be great if we could sidestep the performance problem. One way to do it is with concurrency and parallelism.</p><p><strong>Ruby implementations</strong></p><p>Some say that:</p><blockquote><p><em>Both Python and Ruby have full support for multi-threading. There are some implementations (e.g. CPython, MRI, YARV) which cannot actually run threads in parallel, but that’s a limitation of those specific implementations, not the language. This is similar to Java, where there are also some implementations which cannot run threads in parallel, but that doesn’t mean that Java is single-threaded. Note that in both cases there are lots of implementations which can run threads in parallel: PyPy, IronPython, Jython, IronRuby and JRuby are only few of the examples. <a href=https://stackoverflow.com/questions/3086467/confused-are-languages-like-python-ruby-single-threaded-unlike-say-java-for>Are languages like python and ruby single threaded unlike say java?</a></em></p></blockquote><p>But come on, that’s pure theory. Almost everybody uses MRI, the main Ruby implementation. I think that the main reason is that it’s <a href=http://andrewjgrimm.wordpress.com/2013/07/08/mri-boring-but-reliable/>reliable</a>. However the issue with MRI is that it:</p><blockquote><p><em>has something called a global interpreter lock (GIL). It’s a lock around the execution of Ruby code. This means that in a multi-threaded context, only one thread can execute Ruby code at any one time. So if you have 8 threads busily working on a 8-core machine, only one thread and one core will be busy at any given time. The GIL exists to protect Ruby internals from race conditions that could corrupt data. There are caveats and optimizations, but this is the gist. <a href=http://www.jstorimer.com/blogs/workingwithcode/8085491-nobody-understands-the-gil>Nobody understands the GIL</a>:</em></p></blockquote><p>With GIL or without it (read 2<a href=http://tonyarcieri.com/2012-the-year-rubyists-learned-to-stop-worrying-and-love-the-threads>012: The Year Rubyists Learned to Stop Worrying and Love Threads</a>) it’s pretty clear that:</p><blockquote><p><em>the single-core nature of the canonical Ruby interpreter, MRI (the “Matz Ruby Interpreter”), is limiting Ruby’s potential applications.</em></p></blockquote><p><a href=http://www.igvita.com/2008/11/13/concurrency-is-a-myth-in-ruby/>Parallelism is a Myth in Ruby</a>. While we wait for this to get solved for MRI we can check out <a href=http://www.unlimitednovelty.com/2012/03/why-critics-of-rails-have-it-all-wrong.html>why critics of Rails have it all wrong (and Ruby’s bright multicore future)</a> and learn how to overcome this problem:</p><ul><li>Rubinius is an implementation of Ruby designed for concurrency using native threads to run Ruby code on all the CPU cores. It also has a low-pause generational garbage collector, LLVM-based just-in-time (JIT) native machine code compiler. Pretty badass piece of technology. It’s mainly implemented on Ruby. <a href=https://en.wikipedia.org/wiki/Chicken_or_the_egg>Chicken or the egg?</a>. But it has a big downside: Rubinius currently implements MRI Ruby version 1.8.7. MRI Ruby 1.8.7 was released on April 2008, that’s more than 5 years ago. From what I have read Rubinius is working on implementing the upcoming MRI 2.1 release.</li><li>JRuby runs your Ruby code on the JVM, and that’s why we get real threading. Latest version of JRuby is compatible with MRI Ruby 1.8.7 and 1.9.3. If you haven’t got enough links yet start reading <a href=http://blog.engineyard.com/2011/concurrency-in-jruby>Concurrency in JRuby</a>. <a href=http://youtu.be/t_JJD-AEtNM>JRuby: Insights from Six Years in Production</a> and <a href=http://youtu.be/4TAwkq0aQdE>The Future of JRuby by Charles Nutter and Thomas Enebo</a>.</li></ul><p>Also you got <a href=http://youtu.be/yl_zYzPiDto>Visualizing Garbage Collection in Rubinius, JRuby and Ruby 2.0</a> that will be useful for any of the three implementation we mentioned.</p><p>Even if it’s a synthetic benchmark, this comparison between <a href=http://miguelcamba.com/blog/2013/10/05/benchmarking-the-ruby-2-dot-1-and-rubinius-2-dot-0/>MRI 1.9.3, MRI 2.0.0, MRI 2.1.0dev JRuby 1.7.4 and Rubinius 2.0.0</a> has some interesting information.</p><p>Again I think it’s a good idea to hear what Matsumoto thinks:</p><blockquote><p><em><strong>InfoWorld</strong>: What’s your perspective on alternative Ruby implementations just as JRuby and Rubinius?</em></p><p><em><strong>Matsumoto</strong>: I don’t see any problem about other implementations just because the diversity is very sound, the healthy things they have. And actually Ruby, the language, is very good for productivity but the programming environment differs from application to application. For example, some clients require very stable and multicore applications on top of the JVM. In that kind of field, JRuby works better than my Ruby, actually, which is called C Ruby. For most of the cases, C Ruby is good for Web applications. But in certain situations, JRuby and maybe Rubinius are a better fit for a particular requirement.</em></p></blockquote><hr><h3 id=we-need-a-concurrency-model>We need a concurrency model!</h3><p>Despite having real concurrency or being able to run code in many cores, doesn’t mean it’s easy to do so:</p><p><a href=http://blog.smartbear.com/programming/why-johnny-cant-write-multithreaded-programs/>Why Johnny Can’t Write Multithreaded Programs</a>:</p><blockquote><p><em>Introductory multithreading materials explain what threads are. Then they launch into discussions of how to make those threads work together in various ways, such as controlling access to shared data with locks and semaphores, and perhaps controlling when things happen with events. There’s detailed discussion of condition variables, memory barriers, critical sections, mutexes, volatile fields, and atomic operations. You’re given examples of how to use those low level constructs to do all manner of systems level things. By the time a programmer is halfway through that material, she thinks she knows how to use those primitives in her applications. After all, if you understand how to use something at the systems level, using it at the application level should be trivial, right?</em></p><p><em>This is like teaching a teenager how to build an internal combustion engine from discrete parts and then, without the benefit of any driving instruction, setting him behind the wheel of a car and turning him loose on the roads. The teenager understands how the car works internally, but he has no idea how to drive it from point A to point B.</em></p><p><em>Knowing how threads work at the systems level is mostly irrelevant to understanding how to use them in an application program. I’m not saying that programmers shouldn’t know how things work under the hood, just that they shouldn’t expect that knowledge to be directly applicable to the design or implementation of a business application. After all, knowing the details of the intake, compression, combustion, and exhaust cycle doesn’t help you in getting from home to the grocery store and back.</em></p><p><em>Introductory multithreading textbooks (and computer science courses) shouldn’t be teaching those low level constructs. Rather, they should concentrate on common classes of problems and show developers how to use higher level constructs to solve those problems. For example, a large number of business applications are in concept extremely simple programs: They read data from one or more input devices, apply some arbitrarily complex processing to that data (perhaps querying some other stored data in the process), and then output the results.</em></p></blockquote><p>You need a concurrency model or you will keep recreating one on each project. In my humble opinion, these words about Javascript written by Joe Armstrong, creator of Erlang, apply almost perfectly for Ruby too even if it has <a href=http://blog.smartbear.com/programming/why-johnny-cant-write-multithreaded-programs/>threads, process and fibers</a>.</p><p><a href=http://blog.smartbear.com/programming/why-johnny-cant-write-multithreaded-programs/>Red and Green Callbacks</a>:</p><blockquote><p><em>It’s actually worse, every Javascript programmer who has a concurrent problem to solve must invent their own concurrency model. The problem is that they don’t know that this is what they are doing. Every time a Javascript programmer writes a line of code that says “on this do that” they are actually inventing a new concurrency model, and they haven’t a clue how the code will interleave when it executes.</em></p><p><em>(I actually have a love-hate relationship with Javascript, most parts I love but I hate the concurrency model- that might sound funny since Javascript has no concurrency model — so there’s nothing to hate :-)</em></p><p><em>What’s even more difficult to understand is errors. Errors in multi-threaded callback code with shared memory is something that would give me an extremely large headache.</em></p></blockquote><p>The best concurrency model I know in the Ruby land is the one provided by the family of <a href=https://github.com/celluloid/celluloid>Celluloid</a>. Celluloid, with the help of its sons <a href=https://github.com/celluloid/dcell>DCell</a> — this is the best one — and C<a href=https://github.com/celluloid/celluloid-io>elluloi-io</a>, tries to help you achieve the nirvana described by these two famous quotes:</p><blockquote><p><em>“I thought of objects being like biological cells and/or individual computers on a network, only able to communicate with messages” — <strong>Alan Kay, creator of Smalltalk, on the meaning of “object oriented programming”</strong></em></p><hr><p><em>“Objects can message objects transparently that live on other machines over the network, and you don’t have to worry about the networking gunk, and you don’t have to worry about finding them, and you don’t have to worry about anything. It’s just as if you messaged an object that’s right next door.” -<strong>Steve Jobs describing the NeXT Portable Distributed Object system</strong></em></p><hr><p><strong>Why I like Ruby</strong></p></blockquote><p><img src=https://cdn-images-1.medium.com/max/800/1*U24Mc9wNeiSNp2_eOYIGWg.png alt></p><p>Time to land on Earth. We have spent too much time floating on the sky. I have never explained why I use and like Ruby.</p><p>In comparison with other dynamic type languages it has an awesome set of tools as <a href=https://github.com/bbatsov/rubocop>rubocop</a>, <a href=https://github.com/bbatsov/rubocop>ruby-lint</a> and <a href=https://github.com/troessner/reek>reek</a> that help you analyze your code. Furthermore it has the best <a href=https://github.com/troessner/reek>REPL</a> that I am aware of: <a href=http://pryrepl.org/>pry</a>. Watch <a href=http://youtu.be/D9j_Mf91M0I>REPL driven development with Pry</a> and <a href=http://youtu.be/D9j_Mf91M0I>Pry, The Good Parts!</a> to learn how it can help you speed up your development.</p><p>On the other hand, as I mentioned before, it’s not as fast as C or Java but Ruby core developers are doing an excellent work on that area. For example, check the history of improvements to the <a href=http://tmm1.net/ruby21-rgengc/>Ruby garbage collector</a>.</p><p>Even though I sometimes think that it’s Perl-inherited attitude of having more than <a href=http://www.senktec.com/2013/09/one-way-to-do-it/>one way to do the same thing</a> is overwhelming (for some reason I need to reread <a href=http://www.robertsosinski.com/2008/12/21/understanding-ruby-blocks-procs-and-lambdas/>Understanding Ruby Blocks, Procs and Lambdas</a>every month or so), in general I really like its syntax and semantics. I think it’s a very expressive and intuitive language. In my opinion how good a language is is not defined only by semantics, syntax and performance. I am not an academic. I have not even finished university.</p><p><a href=http://zedshaw.com/essays/master_and_expert.html>The Master, The Expert, The Programmer</a>:</p><blockquote><p><em>Programming is a very new discipline, so there’s not too many master programmers out there. What’s worse is that the few people I would consider masters aren’t very exemplary of the software profession and art. They are typically professors who never write anything under a deadline and are given complete artistic freedom to develop whatever they want.</em></p></blockquote><p>I am not saying this in any mean way. I have huge respect for professors and researchers. But I am not one. I code stuff on a deadline. That’s why for me the community and the tools that it has created are really important. They are the salt and pepper of what I am cooking. This is why I love Ruby. It has a lot of salt and pepper. I particularly like Rails, the most known Ruby framework, and its cut down version <a href=https://github.com/rails-api/rails-api>Rails API</a>, because of the following features:</p><p><a href=http://www.unlimitednovelty.com/2012/08/debunking-nodejs-gish-gallop.html>Debunking the Node.js Gish Gallop</a>:</p><blockquote><p><em><strong>Handled at the middleware layer:</strong></em></p><p><em>Reloading: Rails applications support transparent reloading. This works even if your application gets big and restarting the server for every request becomes non-viable.</em></p><p><em>Development Mode: Rails application come with smart defaults for development, making development pleasant without compromising production-time performance.</em></p><p><em>Test Mode: Ditto test mode.</em></p><p><em>Logging: Rails applications log every request, with a level of verbosity appropriate for the current mode. Rails logs in development include information about the request environment, database queries, and basic performance information.</em></p><p><em>Security: Rails detects and thwarts IP spoofing attacks and handles cryptographic signatures in a timing attack aware way. Don’t know what an IP spoofing attack or a timing attack is? Exactly.</em></p><p><em>Parameter Parsing: Want to specify your parameters as JSON instead of as a URL-encoded String? No problem. Rails will decode the JSON for you and make it available in params. Want to use nested URL-encoded params? That works too.</em></p><p><em>Conditional GETs: Rails handles conditional GET, (ETag and Last-Modified), processing request headers and returning the correct response headers and status code. All you need to do is use the stale? check in your controller, and Rails will handle all of the HTTP details for you.</em></p><p><em>Caching: If you use dirty? with public cache control, Rails will automatically cache your responses. You can easily configure the cache store. HEAD requests: Rails will transparently convert HEAD requests into GET requests, and return just the headers on the way out. This makes HEAD work reliably in all Rails APIs.</em></p><p><em><strong>Handled at the ActionPack layer:</strong></em></p><p><em>Resourceful Routing: If you’re building a RESTful JSON API, you want to be using the Rails router. Clean and conventional mapping from HTTP to controllers means not having to spend time thinking about how to model your API in terms of HTTP.</em></p><p><em>URL Generation: The flip side of routing is URL generation. A good API based on HTTP includes URLs (see the GitHub gist APIfor an example).</em></p><p><em>Header and Redirection Responses: head :nocontent and redirectto userurl(currentuser) come in handy. Sure, you could manually add the response headers, but why?</em></p><p><em>Caching: Rails provides page, action and fragment caching. Fragment caching is especially helpful when building up a nested JSON object. Basic, Digest and Token Authentication: Rails comes with out-of-the-box support for three kinds of HTTP authentication.</em></p><p><em>Instrumentation: Rails 3.0 added an instrumentation API that will trigger registered handlers for a variety of events, such as action processing, sending a file or data, redirection, and database queries. The payload of each event comes with relevant information (for the action processing event, the payload includes the controller, action, params, request format, request method and the request’s full path).</em></p><p><em>Generators: This may be passé for advanced Rails users, but it can be nice to generate a resource and get your model, controller, test stubs, and routes created for you in a single command.</em></p><p><em>Plugins: Many third-party libraries come with support for Rails that reduces or eliminates the cost of setting up and gluing together the library and the web framework. This includes things like overriding default generators, adding rake tasks, and honoring Rails choices (like the logger and cache backend).</em></p></blockquote><p>These features are priceless when a deadline is near cutting your head like a guillotine. I think these features are partly the reason <a href=http://blog.targeterapp.com/post/22984987832/why-we-moved-from-nodejs-to-ror>Why Targeter moved from NodeJS to RoR</a>. This doesn’t mean I don’t like Nodejs, but that discussion is beyond the scope of this post.</p><p>For example, this week, a client asked me to create a button on the admin site so that they could get the emails from the users of the application. It took me less than ten minutes to do it:</p><p><code>invitations_emails = InvitationRequest.pluck(:email)</code>
<code>user_emails = User.pluck(:email)</code>
<code>content = (invitations_emails + user_email).to_csv</code>
<code>send_data content, filename: “emails.csv”</code></p><p>However all this magic ain’t always great, in particular when you have performance issues or library-related bugs. But in most cases it will save you from reinventing the wheel.</p><p>In this same line devise (authentication), paperclip (file attachment library that helps you treat files as any other attribute), kaminari (paginator), geocoder (really simple and complete geocoding solution), koala (Facebook library supporting the Graph and REST API), aws-sdk (self-explanatory), tire (API and DSL for the Elasticsearch search engine) or other alternatives that you can find in <a href=https://www.ruby-toolbox.com/>The Ruby Toolbox</a> will make you cry of joy if your non techincal boss ask you to add a new functionality in a couple of hours.</p><p>Also, cucumber and rspec will be of great utility to check that the commit you did on Monday morning while you are really sleepy won’t destroy everything. I also wanted to mention RVM — the greatest version manager of any language I know — and Ruby Gems. After Nodejs great npm package manager, this is the best one I know.</p><p>At last, I wanted to show you <a href=http://watirwebdriver.com/>watir-webdriver</a>. I bet you can’t find a better api to drive a browser. This is a perfect example of how rich and simple Ruby libraries are:</p><p><code>require ‘watir-webdriver’</code>
<code>b = Watir::Browser.new</code>
<code>b.goto ‘bit.ly/watir-webdriver-demo’</code>
<code>b.text_field(:id =&gt; ‘entry_0').set ‘your name’</code>
<code>b.select_list(:id =&gt; ‘entry_1').select ‘Ruby’</code>
<code>b.select_list(:id =&gt; ‘entry_1').selected? ‘Ruby’</code>
<code>b.button(:name =&gt; ‘submit’).click</code>
<code>b.text.include? ‘Thank you’</code></p><p>I have not mentioned before that Ruby is also an excellent language for creating prototypes or for doing IT related work like dealing with files and parsing strings.</p><p>Finally, if you need to create a webpage or a REST API, specially when you don’t need real-time stuff, with limited time and money I can’t currently imagine a better replacement for Ruby and Rails.</p><hr><h3 id=closing-words>Closing words</h3><p>I won’t deny that Ruby has lost some momentum. But that doesn’t mean the language is dead. <a href=http://www.codinghorror.com/blog/2013/03/why-ruby.html>I think it has matured</a> and that it is a great tool to add to your arsenal as a developer.</p><p><a href="http://www.reddit.com/r/programming/comments/1oi8wd/ruby_is_a_dying_language/?utm_source=rubyweekly&amp;utm_medium=email">frycicle</a> explained it really well in a few words.</p><blockquote><p><em>Shoot, in terms of libraries, language design, and community, Ruby has it all. It’s won’t scale to 10 website levels. And that is ok for it’s use. They usually have to make super specialized software anyways.</em></p></blockquote><p>Even accepting that that Ruby is not dying, we could ask ourselves <a href="http://www.reddit.com/r/programming/comments/1oi8wd/ruby_is_a_dying_language/?utm_source=rubyweekly&amp;utm_medium=email">why hasn’t Ruby won</a>?. The answer is that:</p><blockquote><p><em><strong>Sarah Mei</strong>: this is a game where there is no winning turns out, but there is losing, there is definently losing. […] The best thing that you can do for Ruby is go learn something else and then come back.</em></p><p><a href=https://twitter.com/bascule>@bascule</a> daily amazed at the number of ruby people I come across in the scala and Go worlds too. Ruby opens your mind.</p><p>— Paul Lamb (@PaulLamb) <a href=https://twitter.com/PaulLamb/statuses/426338111094661120>January 23, 2014</a></p></blockquote><p>That’s why you should learn some Python, <a href=http://blog.grok.se/2013/10/on-comparing-languages-c-and-go/>Go</a>, Rust, Erlang, Scala, Haskell, Clojure or any Lisp dialect. Oh, and keep an eye on <a href=http://julialang.org/>Julia</a> and <a href=http://elixir-lang.org/>Elixir</a>!</p></p></main><div class=footer></div></body></html>